package home_work_1;

/*  Изучить приоритетность операторов по таблице в презентации. Сначала посчитать результаты всех ниже приведённых
    примеров устно, а потом проверить в IDE (в случае ошибок свериться с таблицей приоритетов, повторять просчёт
    примеров до полного соответствия). Результатом МОЖЕТ БЫТЬ ОШИБКА компиляции, МОЖЕТ БЫТЬ ОШИБКА выполнения программы
    или корректный результат. Все значения в этих переменных должны быть записаны в int и boolean переменные. Напротив
    каждой строчки нужно написать комментарий с результатом и объяснением почему вы получили такой результат.
	Пояснение: ВНИМАНИЕ --8 значит что вам нужно создать переменную, например а, и проинициализировать её 8, а дальше
	её использовать как --а. Данная переменная во всех выражениях должна равняться 8;
	2.1 5 + 2 / 8
	2.2 (5 + 2) / 8
	2.3 (5 + 2++) / 8
	2.4 (5 + 2++) / --8
	2.5 (5 * 2 >> 2++) / --8
	2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8
	2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
	2.8 6 - 2 > 3 && 12 * 12 <= 119
	2.9 true && false
 */

public class Task2 {
    public static void main(String[] args) {

        int a;
        int b;
        int resultI;
        boolean resultB;

        //2.1 5 + 2 / 8

        // Результат равен 5. Деление 2 / 8 приравнивается к нулю, т.к. операции проходят с примитивами типа int

        resultI = 5 + 2 / 8;
        System.out.println("2.1 5 + 2 / 8 = " + resultI);

        //2.2 (5 + 2) / 8

       /* Результат равен 0. Вначале идет сложение, далее деление 7 на 8 дает ноль т.к. операции проходят с примитивами
            типа int
        */

        resultI = (5 + 2) / 8;
        System.out.println("2.2 (5 + 2) / 8 = " + resultI);

        //2.3 (5 + 2++) / 8
        /*
        Ошибка компиляции. Инкрементировать литералы запрещено, необходимо упаковать литерал в целочисленную переменную
        resultI = (5 + 2++) / 8;
        Результат равен 0. Переменная постинкрементируется после подставления в выражение. Деление 7 на 8 дает ноль.
         */

        b = 2;
        resultI = (5 + b++) / 8;
        System.out.println("2.3 (5 + b++) / 8 = " + resultI);

        //2.4 (5 + 2++) / --8

        /*
        Ошибка компиляции. Инкрементировать и декрементировать литералы запрещено, необходимо упаковать литералы в
        целочисленные переменные.
        resultI = (5 + 2++) / --8;
        Результат равен 1. Постинкрементирование переменной осуществляется после подстановки в выражение,
        предекрементирование до подстановки. Итоговое выражение имеет вид (5 + 2) / 7.
         */

        a = 8;
        b = 2;
        resultI = (5 + b++) / --a;
        System.out.println("2.4 (5 + b++) / --a = " + resultI);

        //2.5 (5 * 2 >> 2++) / --8

        /*
        Ошибка компиляции. Инкрементировать и декрементировать литералы запрещено, необходимо упаковать литералы в
        целочисленные переменные.
        resultI = (5 * 2 >> 2++) / --8;
        Результат равен 0. Постинкрементирование переменной осуществляется после подстановки в выражение,
        предекрементирование до подстановки. Итоговое выражение имеет вид (5 * 2 >> 2) / 7. Вначале идет умножение
        5 * 2, далее смещаем число 10 на 2 бита вправо и получаем 2, далее делим 2 на 7.
         */

        a = 8;
        b = 2;

        resultI = (5 * 2 >> b++) / --a;
        System.out.println("2.5 (5 * 2 >> b++) / --a = " + resultI);

        //2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8

        /*
        Ошибка компиляции. Инкрементировать и декрементировать литералы запрещено, необходимо упаковать литералы в
        целочисленные переменные.
        resultI = (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8;
        Результат равен 1. Постинкрементирование переменной осуществляется после подстановки в выражение,
        предекрементирование до подстановки. Итоговое выражение имеет вид (5 + 7 > 20 ? 68 : 22 * 2 >> 2) / 7. После
        проверки условия тернарного оператора выражение упрощается до вида (22 * 2 >> 2) / 7. Вначале идет умножение
        22 * 2, далее смещаем число 44 на 2 бита вправо и получаем 11, далее делим 11 на 7.
         */

        a = 8;
        b = 2;

        resultI = (5 + 7 > 20 ? 68 : 22 * 2 >> b++) / --a;
        System.out.println("2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> b++) / --a = " + resultI);

        //2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8

        /*
        Ошибка компиляции. Инкрементировать и декрементировать литералы запрещено, необходимо упаковать литералы в
        целочисленные переменные.
        resultI = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
        После упаковки литералов также будет ошибка компиляции, т.к. сравниваемые операнды в выражении имеют типы
        boolean и int.
        a = 8;
        b = 2;
        resultI = (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> b++) / --a;
         */

        System.out.println("2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> b++) / --a = ошибка компиляции");

        //2.8 6 - 2 > 3 && 12 * 12 <= 119

        // Результат false, т.к. правый операнд false.

        resultB = 6 - 2 > 3 && 12 * 12 <= 119;
        System.out.println("2.8 6 - 2 > 3 && 12 * 12 <= 119 = " + resultB);

        //2.9 true && false

        //Результат false, т.к. при логическом операторе И результат будет равен true если оба операнда равны true.

        resultB = true && false;
        System.out.println("2.9 true && false = " + resultB);
    }
}
